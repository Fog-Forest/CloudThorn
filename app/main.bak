from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, field_validator
from typing import Optional, Union
import undetected_chromedriver as uc
from selenium.common.exceptions import TimeoutException
import json
import time

app = FastAPI()


class BrowserRequest(BaseModel):
    method: str
    url: str
    headers: Optional[dict] = None
    timeout: int = 30000
    data: Optional[str] = None

    @classmethod
    def validate_method(cls, v):
        if v.lower() not in ['get', 'post']:
            raise ValueError('Method must be GET or POST')
        return v.lower()

    @classmethod
    def validate_data(cls, v, info):
        if info.data.get('method') == 'post' and v is None:
            raise ValueError('Data is required for POST requests')
        return v


def execute_xhr_request(driver, method, url, headers=None, data=None):
    script = """
    const [method, url, headers, data] = arguments;
    const xhr = new XMLHttpRequest();
    xhr.open(method, url, false);

    if (headers) {
        for (const [key, value] of Object.entries(headers)) {
            xhr.setRequestHeader(key, value);
        }
    }

    xhr.send(data || null);
    return {
        status: xhr.status,
        response: xhr.responseText
    };
    """
    return driver.execute_script(script, method.upper(), url, headers, data)


@app.post("/api/proxy")
async def proxy_request(request: BrowserRequest):
    driver = None
    start_timestamp = int(time.time() * 1000)
    try:
        # 初始化浏览器
        driver = uc.Chrome()
        driver.set_page_load_timeout(request.timeout / 1000)

        # 处理带自定义 Header 的请求
        if request.headers:
            driver.get("about:blank")
            result = execute_xhr_request(
                driver,
                request.method,
                request.url,
                request.headers,
                request.data
            )

            end_timestamp = int(time.time() * 1000)
            if 200 <= result['status'] < 300:
                try:
                    response_data = json.loads(result['response'])
                except json.JSONDecodeError:
                    response_data = result['response']
                return {
                    "url": request.url,
                    "status": result['status'],
                    "headers": request.headers,
                    "response": response_data,
                    "startTimestamp": start_timestamp,
                    "endTimestamp": end_timestamp
                }
            else:
                raise HTTPException(status_code=result['status'], detail=result['response'])

        # 处理普通请求
        else:
            if request.method == 'get':
                driver.get(request.url)
            elif request.method == 'post':
                raise HTTPException(status_code=400, detail="POST requests require headers for data submission")

            end_timestamp = int(time.time() * 1000)
            return {
                "url": request.url,
                "status": 200,
                "headers": {},
                "response": driver.page_source,
                "startTimestamp": start_timestamp,
                "endTimestamp": end_timestamp
            }

    except TimeoutException:
        end_timestamp = int(time.time() * 1000)
        raise HTTPException(status_code=408, detail={
            "url": request.url,
            "status": 408,
            "headers": request.headers if request.headers else {},
            "response": "Request timeout",
            "startTimestamp": start_timestamp,
            "endTimestamp": end_timestamp
        })
    except Exception as e:
        end_timestamp = int(time.time() * 1000)
        raise HTTPException(status_code=500, detail={
            "url": request.url,
            "status": 500,
            "headers": request.headers if request.headers else {},
            "response": str(e),
            "startTimestamp": start_timestamp,
            "endTimestamp": end_timestamp
        })
    finally:
        if driver:
            driver.quit()


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)
